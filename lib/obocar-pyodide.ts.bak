/**
 * Pyodide Integration for Obo Car Library
 * 
 * This file integrates your existing Python obocar library with Pyodide
 * for running Python in the browser.
 */

import { PyodideInterface } from 'pyodide';

// Your complete obocar library code - converted from your python-lib directory
const OBOCAR_INIT_PY = `"""
Obo Car Simulation Library
A lightweight Python library for simulating car dynamics and physics.
Designed to work with Pyodide in browser environments.
"""

from .vehicle import OboChar

def obocar():
    """Create and return a new OboChar instance."""
    return OboChar()

# Make the main classes and functions available at module level
__version__ = "0.1.0"
__author__ = "Obo Car Team"
__all__ = ['obocar', 'OboChar']

print("✅ Obo Car library loaded successfully in Pyodide!")
`;

const OBOCAR_VEHICLE_PY = `"""
Vehicle module for Obo Car Simulation Library
Contains the main OboChar class for car simulation.
"""

import random
import math
import time
from typing import Dict, Tuple, List, Optional


class OboChar:
    """
    Main vehicle class for Obo Car simulation.
    Provides methods for movement, sensors, and status monitoring.
    Designed to work in Pyodide/browser environments.
    """
    
    def __init__(self):
        """Initialize the Obo Car."""
        self.position = [0.0, 0.0]  # x, y coordinates
        self.angle = 0.0  # heading in degrees (0 = north)
        self.speed = 0.0  # current speed
        self.max_speed = 10.0  # maximum speed units per second
        self.battery_level = 100.0  # battery percentage
        self.total_distance = 0.0  # total distance traveled
        self.sensor_range = 20.0  # sensor detection range
        self.obstacles = self._generate_random_obstacles()
        self._event_log = []  # Track events for debugging
        
    def _generate_random_obstacles(self) -> List[Tuple[float, float]]:
        """Generate random obstacles in the environment."""
        obstacles = []
        # Create some interesting obstacle patterns
        obstacle_patterns = [
            # Wall pattern
            [(10, i) for i in range(0, 20, 2)],
            # Scattered obstacles
            [(random.uniform(-30, 30), random.uniform(-30, 30)) for _ in range(8)],
            # Circle pattern
            [(15 * math.cos(math.radians(i)), 15 * math.sin(math.radians(i))) 
             for i in range(0, 360, 45)]
        ]
        
        # Randomly choose a pattern
        chosen_pattern = random.choice(obstacle_patterns)
        obstacles.extend(chosen_pattern)
        
        return obstacles
    
    def _log_event(self, event: str):
        """Log an event for debugging purposes."""
        self._event_log.append({
            'timestamp': time.time(),
            'event': event,
            'position': tuple(self.position),
            'angle': self.angle,
            'battery': self.battery_level
        })
    
    def forward(self, distance: float) -> None:
        """
        Move the car forward by the specified distance.
        
        Args:
            distance: Distance to move forward (in units)
        """
        print(f"🚗 Moving forward {distance} units...")
        self._log_event(f"forward({distance})")
        
        # Calculate new position
        angle_rad = math.radians(self.angle)
        new_x = self.position[0] + distance * math.sin(angle_rad)
        new_y = self.position[1] + distance * math.cos(angle_rad)
        
        self.position = [new_x, new_y]
        self.total_distance += abs(distance)
        
        # Consume battery (1% per unit of distance)
        battery_consumption = abs(distance) * 1.0
        self.battery_level = max(0, self.battery_level - battery_consumption)
        
        print(f"   Position: ({self.position[0]:.1f}, {self.position[1]:.1f})")
        
        # Check for collisions
        self._check_collisions()
    
    def backward(self, distance: float) -> None:
        """
        Move the car backward by the specified distance.
        
        Args:
            distance: Distance to move backward (in units)
        """
        print(f"🔄 Moving backward {distance} units...")
        self.forward(-distance)
    
    def left(self, degrees: float) -> None:
        """
        Turn the car left by the specified degrees.
        
        Args:
            degrees: Degrees to turn left
        """
        print(f"⬅️ Turning left {degrees} degrees...")
        self._log_event(f"left({degrees})")
        self.angle = (self.angle - degrees) % 360
        
        # Small battery consumption for turning
        self.battery_level = max(0, self.battery_level - 0.5)
        print(f"   New heading: {self.angle:.1f}°")
    
    def right(self, degrees: float) -> None:
        """
        Turn the car right by the specified degrees.
        
        Args:
            degrees: Degrees to turn right
        """
        print(f"➡️ Turning right {degrees} degrees...")
        self._log_event(f"right({degrees})")
        self.angle = (self.angle + degrees) % 360
        
        # Small battery consumption for turning
        self.battery_level = max(0, self.battery_level - 0.5)
        print(f"   New heading: {self.angle:.1f}°")
    
    def sensor(self, direction: str = 'front') -> float:
        """
        Get distance reading from the specified sensor.
        
        Args:
            direction: Sensor direction ('front', 'back', 'left', 'right')
            
        Returns:
            Distance to nearest obstacle in meters
        """
        sensor_angles = {
            'front': 0,
            'right': 90,
            'back': 180,
            'left': 270
        }
        
        if direction not in sensor_angles:
            raise ValueError(f"Invalid sensor direction: {direction}. Use: {list(sensor_angles.keys())}")
        
        # Calculate sensor angle
        sensor_angle = (self.angle + sensor_angles[direction]) % 360
        sensor_angle_rad = math.radians(sensor_angle)
        
        # Find nearest obstacle in sensor direction
        min_distance = self.sensor_range
        
        for obstacle_x, obstacle_y in self.obstacles:
            # Calculate distance to obstacle
            dx = obstacle_x - self.position[0]
            dy = obstacle_y - self.position[1]
            distance = math.sqrt(dx**2 + dy**2)
            
            # Calculate angle to obstacle
            angle_to_obstacle = math.degrees(math.atan2(dx, dy))
            angle_diff = abs((angle_to_obstacle - sensor_angle + 180) % 360 - 180)
            
            # If obstacle is in sensor cone (±30 degrees) and closer than current min
            if angle_diff <= 30 and distance < min_distance:
                min_distance = distance
        
        # Add some random noise to simulate real sensor
        noise = random.uniform(-0.2, 0.2)
        result = max(0.1, min_distance + noise)
        
        self._log_event(f"sensor({direction}) = {result:.1f}")
        return result
    
    def battery(self) -> float:
        """
        Get current battery level.
        
        Returns:
            Battery level as percentage (0-100)
        """
        return round(self.battery_level, 1)
    
    def distance(self) -> float:
        """
        Get total distance traveled.
        
        Returns:
            Total distance traveled in units
        """
        return round(self.total_distance, 1)
    
    def wait(self, seconds: float) -> None:
        """
        Wait for the specified number of seconds.
        In Pyodide, this is simulated without blocking.
        
        Args:
            seconds: Time to wait in seconds
        """
        print(f"⏳ Waiting {seconds} seconds...")
        self._log_event(f"wait({seconds})")
        # In browser environment, we simulate the wait without actually blocking
    
    def get_position(self) -> Tuple[float, float]:
        """
        Get current position.
        
        Returns:
            Current (x, y) position
        """
        return (round(self.position[0], 1), round(self.position[1], 1))
    
    def get_heading(self) -> float:
        """
        Get current heading.
        
        Returns:
            Current heading in degrees
        """
        return round(self.angle, 1)
    
    def status(self) -> Dict:
        """
        Get comprehensive status information.
        
        Returns:
            Dictionary containing all status information
        """
        return {
            'position': self.get_position(),
            'heading': self.get_heading(),
            'battery': self.battery(),
            'distance': self.distance(),
            'speed': round(self.speed, 1),
            'obstacles_nearby': self._count_nearby_obstacles()
        }
    
    def _check_collisions(self) -> bool:
        """Check if the car has collided with any obstacles."""
        collision_distance = 1.0  # Collision threshold
        
        for obstacle_x, obstacle_y in self.obstacles:
            dx = obstacle_x - self.position[0]
            dy = obstacle_y - self.position[1]
            distance = math.sqrt(dx**2 + dy**2)
            
            if distance < collision_distance:
                print(f"⚠️ COLLISION! Hit obstacle at ({obstacle_x:.1f}, {obstacle_y:.1f})")
                self.battery_level = max(0, self.battery_level - 10)  # Collision penalty
                return True
        
        return False
    
    def _count_nearby_obstacles(self, radius: float = 10.0) -> int:
        """Count obstacles within specified radius."""
        count = 0
        for obstacle_x, obstacle_y in self.obstacles:
            dx = obstacle_x - self.position[0]
            dy = obstacle_y - self.position[1]
            distance = math.sqrt(dx**2 + dy**2)
            
            if distance <= radius:
                count += 1
        
        return count
    
    def get_obstacles(self) -> List[Tuple[float, float]]:
        """
        Get list of all obstacles in the environment.
        
        Returns:
            List of (x, y) obstacle positions
        """
        return self.obstacles.copy()
    
    def add_obstacle(self, x: float, y: float) -> None:
        """
        Add a new obstacle to the environment.
        
        Args:
            x: X coordinate of obstacle
            y: Y coordinate of obstacle
        """
        self.obstacles.append((x, y))
        print(f"🚧 Added obstacle at ({x:.1f}, {y:.1f})")
    
    def get_event_log(self) -> List[Dict]:
        """
        Get the event log for debugging.
        
        Returns:
            List of logged events
        """
        return self._event_log.copy()
    
    def reset(self) -> None:
        """Reset the car to initial state."""
        self.position = [0.0, 0.0]
        self.angle = 0.0
        self.speed = 0.0
        self.battery_level = 100.0
        self.total_distance = 0.0
        self.obstacles = self._generate_random_obstacles()
        self._event_log = []
        print("🔄 Car reset to initial state")
        self._log_event("reset()")
`;

let pyodideInstance: PyodideInterface | null = null;

/**
 * Initialize Pyodide and load your obocar library
 */
export async function initializeOboCarPyodide(): Promise<PyodideInterface> {
  if (pyodideInstance) {
    return pyodideInstance;
  }

  try {
    console.log('🐍 Loading Pyodide...');
    
    // Import loadPyodide dynamically
    const { loadPyodide } = await import('pyodide');
    
    // Load Pyodide with CDN
    pyodideInstance = await loadPyodide({
      indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.28.2/full/',
    });

    console.log('✅ Pyodide loaded successfully');

    // Install your obocar library by creating proper file structure
    console.log('📦 Installing your obocar library...');
    
    // Create the module directory structure
    // @ts-ignore - Pyodide FS is available but TypeScript doesn't know about it
    pyodideInstance.FS.mkdir('/obocar');
    
    // Write the module files
    // @ts-ignore - Pyodide FS is available but TypeScript doesn't know about it
    pyodideInstance.FS.writeFile('/obocar/__init__.py', OBOCAR_INIT_PY);
    // @ts-ignore - Pyodide FS is available but TypeScript doesn't know about it
    pyodideInstance.FS.writeFile('/obocar/vehicle.py', OBOCAR_VEHICLE_PY);
    
    // Add the directory to Python's path
    await pyodideInstance.runPython(`
import sys
if '' not in sys.path:
    sys.path.insert(0, '')
print(f"Python path: {sys.path}")
print("✅ Module directories created in Pyodide filesystem")
    `);
    
    // Test that the library can be imported properly
    const importTest = await pyodideInstance.runPython(`
try:
    print("Testing import from obocar...")
    from obocar import obocar
    
    print("Testing object creation...")
    car = obocar()
    
    print("Testing basic methods...")
    position = car.get_position()
    heading = car.get_heading()
    battery = car.battery()
    
    print("Testing movement...")
    car.forward(5)
    car.right(45)
    new_position = car.get_position()
    
    result = {
        'success': True,
        'initial_position': position,
        'new_position': new_position,
        'battery': battery,
        'message': 'Obocar library successfully imported and tested!'
    }
    print(f"✅ Import test successful: {result}")
    result  # This explicit return is important
except Exception as e:
    import traceback
    error_traceback = traceback.format_exc()
    error_result = {
        'success': False,
        'error': str(e),
        'traceback': error_traceback
    }
    print(f"❌ Import test failed: {error_result}")
    error_result  # This explicit return is important
`);

    console.log('🧪 Import test result:', importTest);

    if (importTest && !importTest.success) {
      console.error('❌ Import test failed:', importTest.error);
      console.error(importTest.traceback);
      throw new Error(`Module import verification failed: ${importTest.error}`);
    } else if (!importTest) {
      console.error('❌ Import test returned undefined');
      throw new Error('Module import verification failed: No result returned');
    }

    console.log('✅ Obocar library installed and verified');
    return pyodideInstance;
  } catch (error) {
    console.error('❌ Failed to initialize Pyodide:', error);
    pyodideInstance = null;
    throw error;
  }
}

/**
 * Execute Python code with output capture
 */
export async function executePythonCode(code: string): Promise<{ output: string; result?: any }> {
  if (!pyodideInstance) {
    throw new Error('Pyodide not initialized. Call initializeOboCarPyodide() first.');
  }

  try {
    // Simple execution that preserves the module system
    const fullCode = `
import io
import sys

# Capture stdout
captured_output = io.StringIO()
old_stdout = sys.stdout
sys.stdout = captured_output

result = None
try:
    # Execute user code with full Python environment
    result = exec("""${code.replace(/"/g, '\\"')}""")
finally:
    # Restore stdout
    sys.stdout = old_stdout

{
    'output': captured_output.getvalue(),
    'result': result
}
    `;

    const executionResult = await pyodideInstance.runPython(fullCode);
    return {
      output: executionResult.output || 'Code executed successfully',
      result: executionResult.result
    };
  } catch (error) {
    console.error('❌ Python execution error:', error);
    return {
      output: `Error: ${error}`,
      result: null
    };
  }
}

  try {
    // Simple execution that preserves the module system
    const fullCode = `
import io
import sys

# Capture stdout
captured_output = io.StringIO()
old_stdout = sys.stdout
sys.stdout = captured_output

result = None
try:
    # Execute user code with full Python environment
    result = exec("""${code.replace(/"/g, '\\"')}""")
finally:
    # Restore stdout
    sys.stdout = old_stdout

{
    'output': captured_output.getvalue(),
    'result': result
}
    `;

    const executionResult = await pyodideInstance.runPython(fullCode);
    return {
      output: executionResult.output || 'Code executed successfully',
      result: executionResult.result
    };
  } catch (error) {
    console.error('❌ Python execution error:', error);
    return {
      output: `Error: ${error}`,
      result: null
    };
  }
}

/**
 * Run your original test code
 */
export async function runOriginalCode(): Promise<{ output: string; result?: any }> {
  const originalCode = `
# Import the Obo Car library (your original code)
from obocar import obocar

# Create a car instance
car = obocar()

# Basic movement commands
print("🚗 Starting Obo Car simulation!")

# Move forward 3 units
car.forward(3)
car.wait(0.5)

# Check front sensor
front_distance = car.sensor('front')
print(f"Front sensor: {front_distance:.1f}m")

# Make decisions based on sensor data
if front_distance > 5:
    print("Path clear, moving forward")
    car.forward(2)
else:
    print("Obstacle detected, turning right")
    car.right(90)
    car.forward(2)

# Check status
battery = car.battery()
distance = car.distance()
print(f"Mission complete! Battery: {battery:.1f}%, Distance: {distance:.1f}m")

# Return final status
{
    'position': car.get_position(),
    'heading': car.get_heading(),
    'battery': battery,
    'distance': distance
}
`;

  return await executePythonCode(originalCode);
}

/**
 * Run the complete test suite from your test_obocar.py
 */
export async function runTestSuite(): Promise<{ output: string; result?: any }> {
  const testCode = `
# Run comprehensive tests based on your test_obocar.py

def test_car_creation():
    """Test basic car creation."""
    car = obocar()
    assert isinstance(car, OboChar)
    assert car.get_position() == (0.0, 0.0)
    assert car.get_heading() == 0.0
    assert car.battery() == 100.0
    assert car.distance() == 0.0
    print("✅ Car creation test passed")

def test_movement():
    """Test basic movement functions."""
    car = obocar()
    
    # Test forward movement
    initial_pos = car.get_position()
    car.forward(5)
    new_pos = car.get_position()
    assert new_pos != initial_pos
    assert car.distance() == 5.0
    
    # Test turning
    car.right(90)
    assert car.get_heading() == 90.0
    
    car.left(45)
    assert car.get_heading() == 45.0
    
    print("✅ Movement test passed")

def test_sensors():
    """Test sensor functionality."""
    car = obocar()
    
    # Test all sensor directions
    directions = ['front', 'back', 'left', 'right']
    for direction in directions:
        reading = car.sensor(direction)
        assert isinstance(reading, (int, float))
        assert reading >= 0
    
    # Test invalid direction
    try:
        car.sensor('invalid')
        assert False, "Should have raised ValueError"
    except ValueError:
        pass
    
    print("✅ Sensor test passed")

def test_obstacle_interaction():
    """Test obstacle-related functions."""
    car = obocar()
    
    # Get initial obstacles
    initial_obstacles = car.get_obstacles()
    assert isinstance(initial_obstacles, list)
    
    # Add new obstacle
    car.add_obstacle(10, 10)
    new_obstacles = car.get_obstacles()
    assert len(new_obstacles) == len(initial_obstacles) + 1
    assert (10.0, 10.0) in new_obstacles
    
    print("✅ Obstacle interaction test passed")

def test_status_methods():
    """Test status and information methods."""
    car = obocar()
    
    # Test status method
    status = car.status()
    assert isinstance(status, dict)
    required_keys = ['position', 'heading', 'battery', 'distance', 'speed']
    for key in required_keys:
        assert key in status
    
    # Test position and heading
    pos = car.get_position()
    heading = car.get_heading()
    assert isinstance(pos, tuple) and len(pos) == 2
    assert isinstance(heading, (int, float))
    
    print("✅ Status methods test passed")

def test_reset_functionality():
    """Test car reset functionality."""
    car = obocar()
    
    # Make some changes
    car.forward(5)
    car.right(90)
    car.add_obstacle(15, 15)
    
    # Verify changes
    assert car.get_position() != (0.0, 0.0)
    assert car.get_heading() != 0.0
    assert car.battery() < 100.0
    assert car.distance() > 0.0
    
    # Reset and verify
    car.reset()
    assert car.get_position() == (0.0, 0.0)
    assert car.get_heading() == 0.0
    assert car.battery() == 100.0
    assert car.distance() == 0.0
    
    print("✅ Reset functionality test passed")

def test_event_logging():
    """Test event logging functionality."""
    car = obocar()
    
    # Perform some actions
    car.forward(2)
    car.right(45)
    car.sensor('front')
    
    # Check event log
    events = car.get_event_log()
    assert isinstance(events, list)
    assert len(events) > 0
    
    # Check event structure
    for event in events:
        assert isinstance(event, dict)
        assert 'event' in event
        assert 'position' in event
    
    print("✅ Event logging test passed")

# Run all tests
print("🧪 Running your complete test suite...")
print("=" * 50)

tests = [
    test_car_creation,
    test_movement,
    test_sensors,
    test_obstacle_interaction,
    test_status_methods,
    test_reset_functionality,
    test_event_logging
]

passed = 0
failed = 0

for test in tests:
    try:
        test()
        passed += 1
    except Exception as e:
        print(f"❌ {test.__name__} failed: {e}")
        failed += 1

print("=" * 50)
print(f"Tests completed: {passed} passed, {failed} failed")

if failed == 0:
    print("🎉 All tests passed! Your library is working perfectly in Pyodide!")
else:
    print("⚠️ Some tests failed.")

{'passed': passed, 'failed': failed, 'success': failed == 0}
`;

  return await executePythonCode(testCode);
}

export { pyodideInstance };